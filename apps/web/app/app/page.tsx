'use client'

import { useCallback, useEffect, useMemo, useState } from 'react'
import { useRouter } from 'next/navigation'

type SetlistResponse = { artist: string; setlist: string[]; error?: string }
type PlaylistResponse = { playlistId: string; playlistUrl?: string; addedCount: number; notFound: string[]; error?: string }

export default function AppPage() {
  const router = useRouter()
  const [authChecked, setAuthChecked] = useState(false)
  const [isAuthed, setIsAuthed] = useState(false)

  const [artist, setArtist] = useState('')
  const [loadingSetlist, setLoadingSetlist] = useState(false)
  const [songs, setSongs] = useState<string[]>([])
  const [setlistError, setSetlistError] = useState<string | null>(null)

  // Playlist title is fixed based on artist
  const [creating, setCreating] = useState(false)
  const [playlist, setPlaylist] = useState<PlaylistResponse | null>(null)
  const [playlistError, setPlaylistError] = useState<string | null>(null)

  const notFoundCount = useMemo(() => playlist?.notFound?.length ?? 0, [playlist])
  const hasSetlist = songs.length > 0

  // Check session via server (HttpOnly cookie) and hydrate UI state
  useEffect(() => {
    (async () => {
      try {
        const res = await fetch('/api/auth/spotify/me', { cache: 'no-store' })
        setIsAuthed(res.ok)
      } catch {
        setIsAuthed(false)
      }
      // hydrate cached UI state
      try {
        const rawState = localStorage.getItem('setlistify_state')
        if (rawState) {
          const s = JSON.parse(rawState) as Partial<{ artist: string; songs: string[] }>
          if (s.artist) setArtist(s.artist)
          if (Array.isArray(s.songs)) setSongs(s.songs)
        }
      } catch {}
      setAuthChecked(true)
    })()
  }, [])

  // Update document title based on artist
  useEffect(() => {
    if (typeof document === 'undefined') return
    if (artist && artist.trim().length > 0) {
      document.title = `${artist} live setlist generated by Setlistify`
    } else {
      document.title = 'Setlistify'
    }
  }, [artist])

  // Redirect to login if unauthenticated (now that PKCE is stable)
  useEffect(() => {
    if (!authChecked) return
    if (!isAuthed) router.replace('/')
  }, [authChecked, isAuthed, router])

  // Persist minimal UI state across reloads
  useEffect(() => {
    try {
      localStorage.setItem('setlistify_state', JSON.stringify({ artist, songs }))
    } catch {}
  }, [artist, songs])

  // Logout handler (unused in UI, can be wired if needed)
  const logoutSpotify = useCallback(async () => {
    try { await fetch('/api/auth/spotify/logout', { method: 'POST' }) } catch {}
    router.replace('/')
  }, [router])

  const fetchSetlist = useCallback(async () => {
    setSetlistError(null)
    setSongs([])
    setLoadingSetlist(true)
    try {
      const res = await fetch(`/api/worker/setlist/${encodeURIComponent(artist)}`)

      // Safely parse JSON without leaking low-level errors to the UI
      let json: SetlistResponse | null = null
      const ct = res.headers.get('content-type') || ''
      if (ct.includes('application/json')) {
        try {
          json = await res.json()
        } catch (err) {
          console.error('Failed to parse setlist JSON response', err)
        }
      }

      if (!json) {
        // Non-JSON or invalid JSON response
        throw new Error('Failed to fetch setlist. Please try again.')
      }

      if (!res.ok || (json as any).error) {
        // Use server-provided error if present, otherwise a friendly fallback
        throw new Error((json as any).error || 'Failed to fetch setlist. Please try again.')
      }
      setSongs(json.setlist || [])
    } catch (e: any) {
      setSetlistError('Failed to fetch setlist. Please try again.')
    } finally {
      setLoadingSetlist(false)
    }
  }, [artist])

  const fetchSetlistForCreate = useCallback(async (): Promise<string[]> => {
    const res = await fetch(`/api/worker/setlist/${encodeURIComponent(artist)}`)
    const ct = res.headers.get('content-type') || ''
    let json: SetlistResponse | null = null
    if (ct.includes('application/json')) {
      try {
        json = await res.json()
      } catch (err) {
        console.error('Failed to parse setlist JSON response (create flow)', err)
      }
    }
    if (!json || !res.ok || (json as any).error) {
      throw new Error((json as any).error || 'Failed to fetch setlist. Please try again.')
    }
    return json.setlist || []
  }, [artist])

  const createPlaylist = useCallback(async () => {
    setPlaylist(null)
    setPlaylistError(null)
    setCreating(true)
    try {
      const songsToUse = songs.length > 0 ? songs : await fetchSetlistForCreate()
      const res = await fetch(`/api/worker/spotify/playlist`, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ title: `${artist} live setlist generated by Setlistify`, artist, songs: songsToUse }),
        credentials: 'same-origin',
      })
      // Safely parse JSON and avoid surfacing raw parse errors
      let json: PlaylistResponse | null = null
      const ct = res.headers.get('content-type') || ''
      if (ct.includes('application/json')) {
        try {
          json = await res.json()
        } catch (err) {
          console.error('Failed to parse playlist JSON response', err)
        }
      }
      if (res.status === 401) {
        setPlaylistError('Your Spotify session has expired. Please log in again.')
        return
      }
      if (res.status === 403) {
        setPlaylistError('This Spotify account is not authorized to use this app yet. Please contact the app owner to be added or try a different Spotify login method.')
        return
      }
      if (!json) {
        throw new Error('Failed to create playlist. Please try again.')
      }
      if (!res.ok || (json as any).error) {
        throw new Error((json as any).error || 'Failed to create playlist. Please try again.')
      }
      setPlaylist(json)
    } catch (e: any) {
      setPlaylistError('Failed to create playlist. Please try again.')
    } finally {
      setCreating(false)
    }
  }, [artist, songs, fetchSetlistForCreate])

  if (!authChecked) return <main><p>Loading…</p></main>

  return (
    <main>

      <section style={{ display: 'grid', gap: 16 }}>
        <div style={{ display: 'grid', gap: 8 }}>
          <label htmlFor="artist">Artist</label>
          <input
            id="artist"
            value={artist}
            onChange={e => setArtist(e.target.value)}
            placeholder="e.g. Red Hot Chili Peppers"
            style={{ padding: 10, borderRadius: 8, border: '1px solid #ccc' }}
          />
          <button onClick={fetchSetlist} disabled={!artist || loadingSetlist} style={{ padding: '10px 14px', borderRadius: 8 }}>
            {loadingSetlist ? 'Loading…' : 'Fetch last setlist'}
          </button>
          {setlistError && <div style={{ color: 'crimson' }}>{setlistError}</div>}
        </div>

        {hasSetlist && (
          <div style={{ display: 'grid', gap: 8 }}>
            <h3 style={{ margin: '12px 0 4px 0' }}>Songs</h3>
            <ul style={{ margin: 0, paddingLeft: 18 }}>
              {songs.map((s, i) => (
                <li key={`${s}-${i}`}>{s}</li>
              ))}
            </ul>
          </div>
        )}
      </section>

      <hr style={{ margin: '24px 0' }} />

      <section style={{ display: 'grid', gap: 12 }}>
        <h2 style={{ margin: 0 }}>Create Spotify Playlist</h2>
        <button onClick={createPlaylist} disabled={!isAuthed || !artist || creating} style={{ padding: '10px 14px', borderRadius: 8 }}>
          {creating ? 'Creating…' : 'Create playlist from setlist'}
        </button>
        {playlistError && (
          <div style={{ color: 'crimson' }}>
            {playlistError}
            {playlistError.toLowerCase().includes('expired') && (
              <div style={{ marginTop: 8 }}>
                <button type="button" onClick={() => { window.location.href = '/api/auth/spotify/login' }} style={{ padding: '8px 12px', borderRadius: 6 }}>
                  Log in with Spotify
                </button>
              </div>
            )}
          </div>
        )}
        {playlist && (
          <div style={{ background: '#f6f6f6', padding: 12, borderRadius: 8 }}>
            <div>Playlist created!</div>
            <div>Tracks added: {playlist.addedCount} {!!notFoundCount && `(not found: ${notFoundCount})`}</div>
            {playlist.playlistUrl && (
              <a href={playlist.playlistUrl} target="_blank" rel="noreferrer">Open in Spotify</a>
            )}
          </div>
        )}
      </section>
    </main>
  )
}
